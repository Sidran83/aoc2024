exit
final_array
exit
matches.first.scan(r).flatten(1)
matches.first.scan(r)
r = /(\d{1,3}),(\d{1,3})\)/
matches.first.scan(r)
r = /mul\((\d{1,3}),(\d{1,3})\)/
matches.first.scan
matches
exit
inputs
exit
inputs
exit
inputs
exit
inputs
exit
inputs
exit
matches.map { |a, b| a.to_i * b.to_i }
matches
exit
matches
exit
matches
exit
inputs.flatten(1)
inputs
item
exit
result
exit
inputs
matches
exit
lines.first.scan(regex)
exit
lines.first
regex
lines.first.scan(regex)
exit
matches
exit
matches
products = matches.flatten(1).map { |a, b| a.to_i * b.to_i }
matches
exit
products = matches.flatten(1).map { |a, b| a.to_i * b.to_i }
    products = matches.each { |digits| digits.map! { |a, b| a.to_i * b.to_i } }
    products = matches.each { |digits| digits.map { |a, b| a.to_i * b.to_i } }
    products = matches.map { |digits| digits.map { |a, b| a.to_i * b.to_i } }
matches.first.first
matches.first
matches
exit
matches
exit
matches
exit
lines.first.scan(/mul\((\d{1,3},\d{1,3})\)/).first
lines.first.scan(/mul\((\d{1,3},\d{1,3})\)/)
lines.first
exit
matches
exit
matches
exit
matches = text.scan(regex)
regex = /mul\((\d{1,3}),(\d{1,3})\)/
text = "xmul(2,4)%&mul[3,7]!@^do_not_mul(5,5)+mul(32,64]then(mul(11,8)mul(8,5)mul(123,45)mul(999,1000))"
toto.first.first.to_i
toto.first.first
toto.first
lines.first.scan(/mul\(\d{1,3},\d{1,3}\)/).
    toto = lines.map { |line| line.scan(/mul\(\d{1,3},\d{1,3}\)/) }
lines.first.scan(/mul\(\d{1,3},\d{1,3}\)/)
lines.first.select(/mul\(\d{1,3},\d{1,3}\)/)
lines.first.match(/mul\(\d{1,3},\d{1,3}\)/)
lines.first
exit
arr
numbers
 arr = numbers.reject.with_index { |_, i| i == index }
exit
numbers
arr
arr = numbers.delete_at(index)
numbers - numbers.slice(index)
numbers
exit
arr
arr.delete_at(1)
arr
arr.slice(1)
array.slice(1)
arr = [1, 2, 3]
numbers
c
numbers
number
exit
index
numbers
c
numbers.each_cons(2).all? { |a, b| a > b && (a - b).abs < 4 }
numbers.each_cons(2).all? { |a, b| a < b && (a - b).abs < 4 }
numbers
n
numbers
array_length
index
exit
c
index
numbers
c
numbers
c
numbers
exit
numbers.length
numbers
numbers.delete_at(2)
numbers
numbers.length
numbers.class
numbersd.class
numbers.length
numbers
c
numbers
c
numbers.each_cons(2).all? { |a, b| a > b && (a - b).abs < 3 }
 numbers.each_cons(2).all? { |a, b| a < b && (a - b).abs < 3 }
numbers
c
 numbers.each_cons(2).all? { |a, b| a > b && (a - b).abs < 3 }
numbers.each_cons(2).all? { |a, b| a < b && (a - b).abs < 3 }
numbers
c
numbers.each_cons(2).all? { |a, b| a < b && (a - b).abs < 3 }
numbers
c
numbers.each_cons(2).all? { |a, b| a > b && (a - b).abs < 3 }
numbers.each_cons(2).all? { |a, b| a < b && (a - b).abs < 3 }
numbers
counter
c
 numbers.each_cons(2).all? { |a, b| a > b && (a - b).abs < 3 }
 numbers.each_cons(2).all? { |a, b| a < b && (a - b).abs < 3 }
numbers
exit
 (input_a < input_b || input_a > input_b)
exit
input_a < inpupt_b || input_a > input_b
input_a < inpupt_b || input_a > input_bb
a < b || a > b
line
input_b
exit
b
a
line.split.map(&:to_i)
line
exit
count += 1
count ++
count = 0
good
exit
lines.first.split
lines.first
c
part == "1"
part.class
part
c
exit
input_file_path.split(".")[-2] == "1"
input_file_path.split(".")[-2]
input_file_path.split(".")[-1]
input_file_path.split(".")
input_file_path.split
input_file_path
exit
self.class_name
self
lines
c
right_num
left_num
exit
arr_final.sum
arr_final
exit
c
arr_final << ((number.to_i > arr_right[i].to_i) ? number.to_i - arr_right[i].to_i : arr_right[i].to_i - number.to_i)
 arr_right[i].to_i
number.to_i
 (number.to_i > arr_right[i].to_i) ? number.to_i - arr_right[i].to_i : arr_right[i].to_i - number.to_i
 arr_right[i].to_i - number.to_i
number.to_i > arr_right[i].to_i
c
arr_final
exit
exoit
arr_right
arr_right.sort!
arr_right
arr_right.sort
arr_right
arr_left
arr_left.sort!
arr_left.sort
arr_left.sort()
arr_left.order
arr_left
exit
lines.first.split(" ").
lines.first.split(" ")
arr1 = []
lines.first.split(" ")
lines.first
lines

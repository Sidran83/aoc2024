c
position
 position.keys[(position.keys.count / 2.to_f).ceil - 1].to_i
exit
position.keys[(position.keys.count / 2.to_f).ceil - 1].to_i
sequence_respects_rules?(position, couples)
exit
position.keys[(position.keys.count / 2.to_f).ceil - 1].to_i
position.keys[(position.keys.count / 2.to_f).ceil - 1]
(position.keys.count / 2.to_f).ceil - 1
(8 / 2.to_f).ceil
(position.keys.count / 2.to_f).ceil
position.keys.count / 2.to_f.ceil
position.keys.count / 2.to_f.floor
position.keys.count / 2.to_f.ceil
position.keys.count / 2.to_f.round
position.keys.count / 2.to_f
position.keys.count / 2
position.keys.count
position.keys
c
good_sequences
c
good_sequences
c
good_sequences
c
sequence_respects_rules?(position, couples)
exit
position["200"].nil?
position["200"]
sequence_respects_rules?(position, couples)
position.keys
exit
position[before.to_s] < position[after.to_s]
 position[after.to_s]
position[before.to_s]
exit
good_sequences
exit
c
exit
position[after.to_s]
position[after]
position[:after]
 position[:before] && position[:after] && position[:before] < position[:after]
after
position[after]
position
after
before
c
good_sequences
c
exit
couple.keys
couple = updates.first.split(",").each_with_index.to_h
couples = rules.map { |rule| rule.split("|").map(&:to_i) }
couple.first
couple = rules.map { |rule| rule.split("|").map(&:to_i) }
rules.map { |rule| rule.split("|").map(&:to_i) }
rules
rules.map { |rule| rule.split("|").map(&:to_i) }
rules
updates.map { |update| update.split(",").each_with_index.to_h }
updates.first.split(",").each_with_index.to_h
updates.first.each_with_index
updates.each_with_index
updates.each_withÂ°index
updates
rules
exit
lines.first
lines
exit
art.last
art.first
art.count
art
art = File.read(@path).split("\n\n").map { |x| x.split("\n") }
[art, brt]
art, brt
art
brt
art, brt = File.read(@path).split("\n\n").map { |x| x.split("\n") }
b
a, b = File.read(@path).split("\n\n").map { |x| x.split("\n") }
b
a, b = File.read(@path).split("\n\n").map { |a| a.split("\n") }
b
a
a, b, = File.read(@path).split("\n\n").map { |x| x.split("\n") }
b
a
a, b, = File.read(@path).split("\n\n").map { |a| a.split("\n") }
File.read(@path).split("\n\n").class
File.read(@path).split("\n\n")[0].split("\n")
File.read(@path).split("\n\n").split("\n")
File.read(@path).split("\n\n")..split("\n")
File.read(@path).split("\n\n").last
File.read(@path).split("\n\n").first
File.read(@path).split("\n\n")
File.read(@path).split("<br>")
@path
exit
diagonals
exit
diagonals.map(&:join)
diagonals
exit
diagonals
exit
diagonals
exit
lines.map { |line| line.split('') }
lines.map(&:split(""))
lines.map(&:split)
lines.map(&_:split(""))
lines.map(&:split(""))
c
vertical_line
counter
c
vertical_line
counter
c
vertical_line
counter
c
vertical_line
counter
c
vertical_line
counter
c
vertical_line
counter
c
vertical_line
counter
c
counter
vertical_line
c
vertical_line
counter
c
vertical_line
counter
exit
exirt
c
vertical_line
exit
counter
@counter
exit
@lines
lines
@counter
counter
exit
c
line.scan(/SAMX/)
line.scan(/XMAS|SAMX/)
horizontal_scan(line)
line
counter
c
counter
line
c
counter
line
c
counter
line
c
line
counter
exit
counter
c
line.scan(/XMAS|SAMX/).count
line
exit
line.count(/XMAS|SAMX/)
line.scan(/XMAS|SAMX/).count
line.scan(/XMAS|SAMX/)
line.scan(/XMAS | SAMX/)
line.scan("XMAS")
line = "SAMXMMMSXXMASM"
line.scan("XMAS")
line.include?("XMAS")
line.include("XMAS")
line
exit
final_array
exit
matches.first.scan(r).flatten(1)
matches.first.scan(r)
r = /(\d{1,3}),(\d{1,3})\)/
matches.first.scan(r)
r = /mul\((\d{1,3}),(\d{1,3})\)/
matches.first.scan
matches
exit
inputs
exit
inputs
exit
inputs
exit
inputs
exit
inputs
exit
matches.map { |a, b| a.to_i * b.to_i }
matches
exit
matches
exit
matches
exit
inputs.flatten(1)
inputs
item
exit
result
exit
inputs
matches
exit
lines.first.scan(regex)
exit
lines.first
regex
lines.first.scan(regex)
exit
matches
exit
matches
products = matches.flatten(1).map { |a, b| a.to_i * b.to_i }
matches
exit
products = matches.flatten(1).map { |a, b| a.to_i * b.to_i }
    products = matches.each { |digits| digits.map! { |a, b| a.to_i * b.to_i } }
    products = matches.each { |digits| digits.map { |a, b| a.to_i * b.to_i } }
    products = matches.map { |digits| digits.map { |a, b| a.to_i * b.to_i } }
matches.first.first
matches.first
matches
exit
matches
exit
matches

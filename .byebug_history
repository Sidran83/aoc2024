exit
counterexit
counter
c
counter
result == target_sum
result
counter
c
counter
c
counter
c
counter
exit
counter
c
result == target_sum
result
c
counter
c
counter
c
exit
counter
c
counter
c
counter
c
counter
c
result
numbers
c
 result == target_sum
numbers
result
exit
index
numbers
 numbers[index + 1]
exit
numbers[1]
numbers
op
i
numbers[i + 1]
result
exit
str.split
str.split(/[:;]/)
str.split("/[:;]/")
str.split("+ || *")
str = numbers.zip(ops[2]).flatten.compact.join
numbers.zip(ops[2]).flatten.compact.join
eval(numbers.zip(ops[2]).flatten.compact.join)
combinations
eval(numbers.zip(ops[8]).flatten.compact.join)
eval(numbers.zip(ops[7]).flatten.compact.join)
eval(numbers.zip(ops[6]).flatten.compact.join)
eval(numbers.zip(ops[5]).flatten.compact.join)
eval(numbers.zip(ops[4]).flatten.compact.join)
numbers.zip(ops[4]).flatten.compact.join
eval(numbers.zip(ops[3]).flatten.compact.join)
numbers.zip(ops[3]).flatten.compact.join
numbers.zip(ops[2]).flatten.compact.join
eval(numbers.zip(ops[2]).flatten.compact.join)
eval(numbers.zip(ops[1]).flatten.compact.join)
 expression = numbers.zip(ops[1]).flatten.compact.join
result = eval(expression)
 expression = numbers.zip(ops[0]).flatten.compact.join
ops = combinations
 expression = numbers.zip(ops).flatten.compact.joicombinations[0]
combinations.count
combinations = operators.repeated_permutation(numbers.size - 1).to_a
operators = %w(+ *)
 target_sum = target_sum.to_i
numbers = numbers.split.map(&:to_i)
target_sum, numbers = line.split(": ")
line
counter
c
counter
line
c
line
c
line
c
line
c
line
c
line
counter
n
combinations
n
numbers
target_sum
n
counter
line
c
line
counter
exit
counter
exit
numbers.zip(combinations.first).flatten.compact
numbers.zip(combinations.first).flatten
numbers.zip(combinations.first)
numbers.zip(combinations.first).flatten.compact.join
numbers.zip(["+"])
.zip(["+"])
numbers
[1, 2, 3].zip(["+"]).flatten.compact.join
[1, 2, 3].zip(["+"]).flatten.compactjoin
[1, 2, 3].zip(["+"]).flatten.compact
[1, 2, 3].zip(["+"]).flatten
[1, 2, 3].zip(["+"])
[1, 2, 3].zip("+")
[1, 2, 3].zip(+)
eval(rot)
rot = numbers.zip(combinations.first).flatten.compact.join
numbers.zip(combinations.first).flatten.compact.join.class
numbers.zip(combinations.first).flatten.compact.join
combinations.first
exit
numbers.size
numbers
combinations
combinations.first
exit
operators.repeated_permutation(numbers.size - 1).to_a
numbers
numbers = numbers.split.map(&:to_i)
numbers
target_sum
exit
operators.split.map(&:to_i).sum(*)
operators.split.map(&:to_i).sum
operators.split.map(&:to_i)
result, operators = lines.first.split(": ")
operators.split.map(&:to_i)
operators.split
result, operators = lines.first.split(": ")
result, opeators = lines.first.split(": ")
opeators.
result
result, opeators = lines.first.split(":")
lines.first.split(":")
lines.first
lines.count
lines
exit
lines.first
lines
exit
@lines.flatten.count { |el| el == "X"}
exit
@lines.flatten.uniq
@lines.flatten.count { |el| el == "X"}
@lines.flatten
@lines.flatten.count
c
exit
line[15].nil?
line[15]
line[11]
line
line.length
counter
n
counter
n
counter
n
counter
n
counter
line.length
n
c
line.length
counter
n
c
counter
n
line
exit
c
exit
line
c
exit
c
itinerary
c
itinerary
c
itinerary
c
itinerary
c
itinerary
exit
itinerary
c
@lines.flatten.count { |e| e == "X" }
cc
c
@lines.flatten.count { |e| e == "X" }
c
@lines.flatten.count { |e| e == "X" }
c
@lines.flatten.count { |e| e == "X" }
c
@lines.flatten.count { |e| e == "X" }
c
@lines.flatten.count { |e| e == "X" }
@lines
c
@lines.flatten.count { |e| e == "X" }
c
@lines.transpose
@lines.flatten.count { |e| e == "X" }
c
@lines.flatten.count { |e| e == "X" }
c
@lines
@lines.transpose
@lines.flatten.count { |e| e == "X" }
c
@lines.flatten.count { |e| e == "X" }
@lines.transpose
c
@lines.transpose
@lines.flatten.count { |e| e == "X" }
c
@lines.flatten.count { |e| e == "X" }
exit
@lines
@lines.flatten.count { |e| e == "X" }
lines
lines.transpose
c
lines.transpose
lines
@lines.flatten.count { |e| e == "X" }
exit
@lines.flatten.count { |e| e == "X" }
c
